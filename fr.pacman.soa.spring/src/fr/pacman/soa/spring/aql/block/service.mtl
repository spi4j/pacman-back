[module service(	'http://www.obeonetwork.org/dsl/soa/4.0.0', 
					'http://www.obeonetwork.org/dsl/entity/3.0.0',
					'http://www.obeonetwork.org/dsl/environment/3.0.0')/]

[import fr::pacman::core::aql::base/]
[import fr::pacman::core::aql::string/]
[import fr::pacman::core::aql::versions/]
[import fr::pacman::core::aql::output::headers/]
[import fr::pacman::core::aql::output::comments/]
[import fr::pacman::core::aql::name::classes/]
[import fr::pacman::core::aql::name::eobjects/]
[import fr::pacman::core::aql::name::packages/]
[import fr::pacman::core::aql::query::eobject/]
[import fr::pacman::core::aql::query::service/]
[import fr::pacman::core::aql::query::operation/]
[import fr::pacman::core::aql::query::parameter/]
[import fr::pacman::core::aql::query::application/]
[import fr::pacman::core::aql::output::resources/]
[import fr::pacman::core::aql::query::dto/]
[import fr::pacman::core::aql::rule::attribute/]
[import fr::pacman::core::aql::rule::parameter/]
[import fr::pacman::core::aql::rule::method/]
[import fr::pacman::core::aql::rule::variable/]
[import fr::pacman::core::aql::rule::class/]
[import fr::pacman::core::aql::rule::common/]

[import fr::pacman::core::property::project::ProjectProperties/]
[import fr::pacman::core::service::AnnotationUtils/]

[comment écriture de l'implémentation d'un service contrôleur soa (couche application)./]
[template public serviceRsImpl (s : soa::Service, ds : OrderedSet(environment::DTO))]
  [s.classHeader(s.namePackageRsControllerImpl())/]
  [protected ('imports'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
    
    [s.defaultImports()/]
    
    import org.springframework.http.HttpStatus;
    import org.springframework.http.MediaType;
    import org.springframework.http.ResponseEntity;
    import org.springframework.http.HttpHeaders;
    import org.springframework.stereotype.Controller;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.web.bind.annotation.CookieValue;
    import org.springframework.web.bind.annotation.DeleteMapping;
    import org.springframework.web.bind.annotation.GetMapping;
    import org.springframework.web.bind.annotation.PathVariable;
    import org.springframework.web.bind.annotation.PostMapping;
    import org.springframework.web.bind.annotation.PutMapping;
    import org.springframework.web.bind.annotation.RequestMapping;
    import org.springframework.web.bind.annotation.RequestBody;
    import org.springframework.web.bind.annotation.RequestParam;
    import org.springframework.web.bind.annotation.RequestMethod;
    import org.springframework.web.bind.annotation.RequestAttribute;  
    import org.springframework.web.bind.annotation.RequestHeader;
    import org.springframework.web.bind.annotation.ResponseBody;
    import org.springframework.security.access.prepost.PreAuthorize;
    
    import io.swagger.v3.oas.annotations.Operation;
    import io.swagger.v3.oas.annotations.Parameter;
    import io.swagger.v3.oas.annotations.enums.ParameterIn;
    import io.swagger.v3.oas.annotations.media.Content;
    import io.swagger.v3.oas.annotations.media.Schema;
    import io.swagger.v3.oas.annotations.Parameter;
    import io.swagger.v3.oas.annotations.responses.ApiResponse;
    import io.swagger.v3.oas.annotations.responses.ApiResponses;
    import io.swagger.v3.oas.annotations.security.SecurityRequirement;
    import io.swagger.v3.oas.annotations.tags.Tag;
    
    import [s.namePackageProject()/].[s.namePackageOutItf()/].[s.nameClassServiceOutItf()/];
    import [s.namePackageProject()/].[s.namePackageInItf()/].[s.nameClassServiceInItf()/];
    import [s.namePackageProject()/].[s.namePackageException()/].[s.nameClassRsDataNotFoundExceptionImpl()/];
    
    [for (d | ds)]
      import [s.namePackageProject()/].[d.namePackageMapperInImpl()/].[d.nameClassMapperImpl()/];
    [/for]
    
  [/protected]
  
  [s.commentClass()/]  
  @Controller
  @RequestMapping("[s.rsUri()/]")
  @Tag(name = "[s.name()/]", description = "[s.writeDescription()/]")
  [protected (s.name.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
  [/protected]
  class [s.nameClassRsServiceImpl()/]
  {
    
    ['Interface service métier'.commentMultiLines()/]
    private final [s.nameClassServiceInItf()/] [s.name().apply_attributeFinal()/];
    
    ['Constructeur'.commentMultiLines()/]
    @Autowired
    public [s.nameClassRsServiceImpl()/](final [s.nameClassServiceInItf()/] [s.name().apply_parameterMethodClassicInOut()/])
    {
      [s.prefixAffectation()/][s.name().apply_attributeFinal()/] = [s.name().apply_parameterMethodClassicInOut()/];
    }
    
    [for (o : soa::Operation | s.ownedInterface.ownedOperations)]
      [if (o.isRsOperation())]
        [o.commentOperation()/]
        [protected ((o.name + 'annotation').protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
        [/protected]
        [o.writeRsAnnotations()/]
        [o.writeRsSwaggerAnnotation(o.securityRsScheme())/]
        [o.writeRsSignature()/]
        {
           [o.lineSeparator()/]
           [o.writeRsResponseBuilder()/]
           
           [protected (o.name.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
             
             [o.writeCheckPageParam()/]
             [o.writeCheckSizeParam()/]
             [o.writeSortByParam()/]
             [o.writeRsHeadOptionOperation(s)/]
             
           [/protected]
           
           [o.writeRsOperation(s)/] 
        }
      [/if]
    [/for]
  }
[/template]

[comment écriture de l'implémentation pour le service de persistance crud (couche infrastructure)./]
[template public crudOutImpl(d : environment::DTO)]
  [d.classHeader(d.namePackageCrudOutImpl())/]
  [protected ('imports'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
    
    [d.defaultImports()/]
    import [d.namePackageProject()/].[d.namePackageCrudOutItf()/].[d.nameClassServiceCrudOutItf()/];
    import [d.namePackageProject()/].[d.namePackageCommonBase()/].[d.nameClassAnnotationOut()/]; 
    import [d.namePackageProject()/].[d.namePackageDtoImpl()/].[d.nameClassDtoImpl()/]; 
    import [d.namePackageProject()/].[d.namePackageMapperOutImpl()/].[d.nameClassMapperImpl()/]; 
    import [d.namePackageProject()/].[d.associatedEntity().namePackageEntityPersistItf()/].[d.associatedEntity().nameClassEntityPersistItf()/]; 
    
  [/protected]
  
  @[d.nameClassAnnotationOut()/]
  public class [d.nameClassServiceCrudOutImpl()/] implements [d.nameClassServiceCrudOutItf()/]
  {
  
    ['Le gestionnaire de persistance'.commentSingleLine()/]
    private [d.associatedEntity().nameClassEntityPersistItf()/] [d.nameRepository().apply_attributeDefault()/];
    
    ['Constructeur avec injection des parametres'.commentMultiLines()/]
    public [d.nameClassServiceCrudOutImpl()/](final [d.associatedEntity().nameClassEntityPersistItf()/] [d.nameRepository().apply_parameterMethodClassicIn()/]){
      
      [d.prefixAffectation()/][d.nameRepository().apply_attributeDefault()/] = [d.nameRepository().apply_parameterMethodClassicIn()/];
    }
    
    @Override
    public void ['save'.apply_methodDefault()/](final [d.nameClassDtoImpl()/] [d.name().apply_parameterMethodClassicIn()/]) {
       [d.prefixAffectation()/][d.nameRepository().apply_attributeDefault()/]
          .save([d.nameClassMapperImpl()/].[('to ' + d.suffixEntity()).apply_methodDefault()/]([d.name().apply_parameterMethodClassicIn()/]));
    }
    
    @Override
    public void ['update'.apply_methodDefault()/](final [d.nameClassDtoImpl()/] [d.name().apply_parameterMethodClassicIn()/]) {
       [d.prefixAffectation()/][d.nameRepository().apply_attributeDefault()/]
          .save([d.nameClassMapperImpl()/].[('to ' + d.suffixEntity()).apply_methodDefault()/]([d.name().apply_parameterMethodClassicIn()/]));
    }
    
    @Override
    public void ['delete'.apply_methodDefault()/](final [d.nameClassDtoImpl()/] [d.name().apply_parameterMethodClassicIn()/]) {
       [d.prefixAffectation()/][d.nameRepository().apply_attributeDefault()/]
         .delete([d.nameClassMapperImpl()/].[('to ' + d.suffixEntity()).apply_methodDefault()/]([d.name().apply_parameterMethodClassicIn()/]));    
    }
    
    @Override
    public void ['find by id'.apply_methodDefault()/](final [d.nameClassDtoImpl()/] [d.name().apply_parameterMethodClassicIn()/]) {
       [d.prefixAffectation()/][d.nameRepository().apply_attributeDefault()/]
         .findById([d.name().apply_parameterMethodClassicIn()/].[d.associatedEntity().nameSimplePropertyID().apply_methodGet()/]());
    }
  }
[/template]

[comment écriture de l'implémentation pour le service avec appel externe (couche infrastructure)./]
[template public outExtImpl(s : soa::Service, ds : OrderedSet(environment::DTO))]
  [s.classHeader(s.namePackageOutImpl())/]
  [protected ('imports'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
    
    [s.defaultImports()/]
    import io.github.resilience4j.circuitbreaker.annotation.CircuitBreaker;
    import [s.namePackageProject()/].[s.namePackageOutItf()/].[s.nameClassServiceOutItf()/];
    import [s.namePackageProject()/].[s.namePackageCommonBase()/].[s.nameClassAnnotationOut()/];
    import [s.namePackageProject()/].[s.namePackageCommonException()/].[s.nameClassNotImplementedExceptionImpl()/];  
    
  [/protected]
  
  [s.commentInterface()/]
  @[s.nameClassAnnotationOut()/]
  public class [s.nameClassServiceOutExtImpl()/] implements [s.nameClassServiceOutItf()/]
  {
    [for (o : soa::Operation | s.ownedInterface.ownedOperations)]
      [o.commentOperation()/]
      @Override
      @CircuitBreaker(name = "[(o.name().apply_variableDefault() + ' circuit breaker').apply_attributeDefault()/]"
         , fallbackMethod = "[(o.name() + ' fallback').apply_methodDefault()/]")
      [o.writePersistSignature()/]
      {
         
         [protected ((o.name() + ' circuit breaker').protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
           
           throw new [s.nameClassNotImplementedExceptionImpl()/] 
                    ("La méthode '[o.nameOperation()/]' n'a pas été implémentée");
                    
         [/protected]
      }
      
      /**
      * Méthode de repli pour {@link #[o.name()/]} en cas d'échec ou d'indisponibilité
      * du service externe. Il est à noter que cette méthode doit avoir exactement
      * les mêmes paramètres (dans le même ordre) que la méthode principale, seule
      * une exception de type 'Throwable' est ajoutée en fin de signature.
      */
      [o.writeRsFallbackSignature()/] {
         
         [protected ((o.name() + ' fallback').protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
           
           // Logique de repli (par exemple, retourner une réponse par défaut)
           throw new [s.nameClassNotImplementedExceptionImpl()/] 
                   ("La méthode '[o.nameOperation()/]' de fallback n'a pas été implémentée");
               
         [/protected]
      }
      
    [/for]
  }
[/template]

[comment écriture de l'implémentation pour le service de persistance (couche infrastructure)./]
[template public outImpl(s : soa::Service, ds : OrderedSet(environment::DTO))]
  [s.classHeader(s.namePackageOutImpl())/]
  [protected ('imports'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
    
    [s.defaultImports()/]
    import jakarta.persistence.EntityManager;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.data.domain.Page;
    import org.springframework.data.domain.PageRequest;
    import org.springframework.data.domain.Sort;
    import [s.namePackageProject()/].[s.namePackageOutItf()/].[s.nameClassServiceOutItf()/];
    import [s.namePackageProject()/].[s.namePackageCommonBase()/].[s.nameClassAnnotationOut()/];
    import [s.namePackageProject()/].[s.namePackageCommonException()/].[s.nameClassNotImplementedExceptionImpl()/];  
  
    [for (d | ds)]
      import [s.namePackageProject()/].[d.namePackageMapperOutImpl()/].[d.nameClassMapperImpl()/];
      [if (d.isPersistent())]
        import [s.namePackageProject()/].[d.associatedEntity().namePackageEntityImpl()/].[d.associatedEntity().nameClassEntityImpl()/];
        import [s.namePackageProject()/].[d.associatedEntity().namePackageEntityPersistItf()/].[d.associatedEntity().nameClassEntityPersistItf()/];
      [/if]
    [/for]
    
  [/protected]
  
  [s.commentInterface()/]
  @[s.nameClassAnnotationOut()/]
  public class [s.nameClassServiceOutImpl()/] implements [s.nameClassServiceOutItf()/]
  {
      
      [protected ('gestionnaires de persistance custom'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
      [/protected]
      
      [let em = ds->hasJpaEntityManager()]
        [em.writeJpaEntityManager()/]
        ['Gestionnaires de persistance disponibles'.commentSingleLine()/]
        [for (d | ds->select(o | o.isPersistent()))]
          final [d.associatedEntity().nameClassEntityPersistItf()/] [d.nameRepository().apply_attributeFinal()/];
        [/for]
      
        ['Constructeur'.commentMultiLines()/]
        @Autowired
        public [s.nameClassServiceOutImpl()/] ([ds->writePersistInputs(em)/])
        {
           
           [ds->writePersistAffectation(em)/]
           
           [protected ('constructeur'.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
           [/protected]
        }
      [/let]
      
      [for (o : soa::Operation | s.ownedInterface.ownedOperations)]
        [if (o.fsd())]
          [o.commentOperation()/]
          @Override
          [o.writePersistSignature()/]
          {
            
            [protected (o.name.protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
            [/protected]
            
            [o.writePersistOperation(s)/]
          }
          
          [o.commentOperation()/]
          [o.writePersistSignatureInvoke()/]
          {
              
              [protected ((o.name + '_invoke').protectedId()) startTagPrefix('// ') endTagPrefix('// ')]
                
                throw new [s.nameClassNotImplementedExceptionImpl()/] 
                  ("La méthode '[o.nameOperation()/]' n'a pas été implémentée");
                  
              [/protected]
          }
        [/if]
      [/for]
  }
[/template]

[comment écriture de l'implémentation pour la classe de définition openapi (swagger)./]
[template public openApiConfigImpl(m :soa::System)]
   [m.classHeader(m.namePackageRsBase())/]
   
   import io.swagger.v3.oas.annotations.OpenAPIDefinition;
   import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
   import io.swagger.v3.oas.annotations.info.Info;
   import io.swagger.v3.oas.annotations.security.SecurityRequirement;
   import io.swagger.v3.oas.annotations.security.SecurityScheme;
   import io.swagger.v3.oas.annotations.enums.SecuritySchemeIn;
   import io.swagger.v3.oas.annotations.security.OAuthFlow;
   import io.swagger.v3.oas.annotations.security.OAuthFlows;
   import io.swagger.v3.oas.annotations.security.OAuthScope;
   import io.swagger.v3.oas.annotations.servers.Server;
   import io.swagger.v3.oas.annotations.info.License;
   import io.swagger.v3.oas.annotations.info.Contact;
   
   import org.springframework.context.annotation.Configuration;
   
   /**
    * Configuration de la documentation OpenAPI pour ce composant.
    * 
    * Cette classe déclare la configuration générale de l'API pour Springdoc. Elle
    * permet de définir les métadonnées principales de la documentation Swagger,
    * telles que le titre, la version, la description, les informations de contact,
    * les termes de licence et d'utilisation.
    *
    * Aucun code métier ou logique n’est présent ici, uniquement des déclarations
    * d’annotations à but documentaire.
    *
    * @see io.swagger.v3.oas.annotations.OpenAPIDefinition
    * @see io.swagger.v3.oas.annotations.info.Info
    * @see org.springframework.context.annotation.Configuration
    */
   @Configuration
   [if (not m.eAllContents(soa::Component)->isEmpty())]
     [m.eAllContents(soa::Component)->first().writeRsSwaggerAnnotations(m.securityRsScheme())/]
   [/if]
   class [m.nameClassOpenApiConfigImpl()/]{}
[/template]

[comment vérifie si il y a besoin d'injecter l'entity manager de jpa dans le service./]
[query private hasJpaEntityManager(ds : OrderedSet(environment::DTO)) : Boolean = not ds->select(o | o.isPersistent() 
  and o.associatedEntity().has_metaEntityManager())->asSet()->isEmpty()/]

[comment écriture pour la mise à disposition de l'entity manager jpa pour le service (si demandé)./]
[query private writeJpaEntityManager(em : Boolean) : String = if (em) then 'Le gestionnaire de persistance de jpa'.commentSingleLine() 
  + 'final EntityManager ' + 'entity manager'.apply_attributeFinal() + ';' + em.lineSeparator() + ' ' else '' endif/]

[comment ?????./]
[query private fsd(o : soa::Operation) : Boolean =  if (o.hasOutput()) then 
  if(o.output->first().type.oclIsKindOf(environment::DTO)) then if (o.output->first().type.oclAsType(environment::DTO).isPersistent()) 
  then true  else  false  endif else  true endif else true endif /]
  
[comment écriture de l'éventuel paramètre de pagination./]
[query private writeSortByParam(o : soa::Operation) : String = if (o.paged) then 'final String ' + 'sort by'.apply_variableDefault() + '= "' 
	+ '";' else '' endif/]
  
[comment écriture de la vérification et de l'affectation des éventuels paramètres de pagination./]
[query private writeCheckPageParam(o : soa::Operation) : String = if (o.paged) then o.input
	->select(o1 | o1.technicalid.equalsIgnoreCase(o.page.technicalid) and not o1.isMandatory())
	->collect(o2 | 'if(null == ' + o2.name() + ')' +  o2.name + ' = 0;')->first() else '' endif/]
  
[comment écriture de la vérification et de l'affectation des éventuels paramètres de pagination./]
[query private writeCheckSizeParam(o : soa::Operation) : String = if (o.paged) then o.input
	->select(o1 | o1.technicalid.equalsIgnoreCase(o.size.technicalid) and not o1.isMandatory())
	->collect(o2 | 'if(null == ' + o2.name() + ')' +  o2.name + ' = 20;')->first() else '' endif/]
 
[comment 	écriture du corps de l'opération pour la couche de persistance, sert d'aiguillage pour les autres queries en fonction du type de sortie.
			on rappelle juste qu'on ne peut générer qu'a partir du momment ou on a des DTOs en paramètre./] 
[query private writePersistOperation(o : soa::Operation, s : soa::Service) : String = if (o.paged) then o.writePagedNonOptionalOutputStar() 
  else if (o.hasOutput()) then if (o.output->first().isOptional()) then if (o.output->first().isMultiple()) then o.writeOptionalOutputStar(s) 
  else o.writeOptionalOutputOne() endif else if (o.output->first().isMultiple()) then o.writeNonOptionalOutputStar(s) 
  else o.writeNonOptionalOutputOne() endif endif else '' endif endif/]

[comment écriture spécifique pour une opération de liste paginée./]
[query private writePagedNonOptionalOutputStar(o : soa::Operation) : String = 'Page<' + if (o.output->first().type.oclIsKindOf(environment::DTO)) 
  then o.output->first().type.oclAsType(environment::DTO).associatedEntity().nameClassEntityImpl() else o.output->first().type endif 
  + '>' + 'page entity'.apply_variableDefault() + ' = ' + o.nameOperation() + '_invoke(' + 'PageRequest.of(' + o.page.name().apply_variableDefault() 
  + ', ' + o.size.name().apply_variableDefault() + ', Sort.by(' + 'sort by'.apply_variableDefault() + ')));' + o.lineSeparator() + 'return '
  + 'page entity'.apply_variableDefault() + '.getContent().stream().map(o -> ' + o.persistDto().nameClassMapperImpl() + ('.to ' 
  + o.suffixDto()).apply_methodDefault() +  + '(o)).collect(Collectors.toList());'/]

[comment écriture de l'appel pour une sortie liste et optionnelle (normalement jamais appelé pour l'instant)./]
[query private writeOptionalOutputStar(o : soa::Operation, s : soa::Service) : String = 'return ' + if (o.output->first().type.oclIsKindOf(environment::DTO)) 
  then o.nameOperation() + '_invoke(' + o.input->collect(o1 | o1.name().apply_parameterMethodClassicIn())->sep(', ') +').stream().map(o -> ' 
  +  o.persistDto().nameClassMapperImpl() + ('.to ' + o.suffixDto()).apply_methodDefault() + '(o)).collect(Collectors.toList());' 
  else o.nameOperation() + '_invoke(' + o.input->collect(o1 | o1.name().apply_parameterMethodClassicIn())->sep(', ') +');' endif/]

[comment écriture de l'appel pour une sortie liste (pour l'instant celle qui est toujours appelée)./]       	    	
[query private writeNonOptionalOutputStar(o : soa::Operation, s : soa::Service) : String = 'return ' 
  + if (o.output->first().type.oclIsKindOf(environment::DTO)) then o.nameOperation() + '_invoke(' + o.input->collect(o1 | o1.name()
  .apply_parameterMethodClassicIn())->sep(', ') +').stream().map(o -> ' + o.persistDto().nameClassMapperImpl() 
  + ('.to ' + o.suffixDto()).apply_methodDefault() + '(o)).collect(Collectors.toList());' else o.nameOperation() 
  + '_invoke(' + o.input->collect(o1 | o1.name().apply_parameterMethodClassicIn())->sep(', ') + ');' endif/]

[comment écriture de l'appel pour une sortie simple mais optionnelle./]
[query private writeOptionalOutputOne(o : soa::Operation) : String = if (o.output->first().type.oclIsKindOf(environment::DTO)) then  
  o.outputPersistType() + ' ' +  o.suffixEntity().apply_variableDefault() + ' = ' +  o.nameOperation() + '_invoke(' + o.input->collect(o1 | o1.name()
  .apply_parameterMethodClassicIn())->sep(', ') + ');' + 'if ( ' + o.suffixEntity().apply_variableDefault() + '.isPresent()) ' 
  + '{ return Optional.of( ' + o.output->first().type.oclAsType(environment::DTO).nameClassMapperImpl() + ('.to ' + o.suffixDto()).apply_methodDefault() 
  + '(' + o.suffixEntity().apply_variableDefault() + '.get()));} return Optional.empty();' else 'return ' + o.nameOperation() + '_invoke(' 
  + o.input->collect(o1 | o1.name().apply_parameterMethodClassicIn())->sep(', ') + ');'  endif/]
                  
[comment écriture de l'appel pour une sortie simple (voir si on complexifie plus tard)./]
[query private writeNonOptionalOutputOne(o : soa::Operation) : String = 'return ' + if (o.output->first().type.oclIsKindOf(environment::DTO)) 
  then o.output->first().type.oclAsType(environment::DTO).nameClassMapperImpl() + ('.to ' + o.suffixDto()).apply_methodDefault() 
  + '('  + o.nameOperation() + '_invoke(' + o.input->collect(o1 | o1.name().apply_parameterMethodClassicIn())->sep(', ') + '));' 
  else o.nameOperation() + '_invoke(' + o.input->collect(o1 | o1.name().apply_parameterMethodClassicIn())->sep(', ') + ');' endif /]
  
[comment écriture de la signature pour le constructeur afin d'injecter les couches de persistance./]
[query private writePersistInputs(ds : OrderedSet(environment::DTO), em : Boolean) : String = ds->select(o1 | o1.isPersistent())->collect(o2 | 'final ' 
  + o2.associatedEntity().nameClassEntityPersistItf() + ' ' +  o2.nameRepository().apply_parameterMethodClassicIn())->sep(', ')->toString() + 
  if (em) then ', EntityManager ' + 'entity manager'.apply_parameterMethodClassicIn() else '' endif/]

[comment écriture de l'affectation pour la couche de persistance dans le constructeur./]
[query private writePersistAffectation(ds : OrderedSet(environment::DTO), em : Boolean) : String = ds->select(o1 | o1.isPersistent())
  ->collect(o2 | o2.prefixAffectation() + o2.nameRepository().apply_attributeFinal() + ' = ' + o2.nameRepository().apply_parameterMethodClassicIn())->sep(';' 
  + ds.lineSeparator())->toString() + if (not ds->select(o1 | o1.isPersistent())->isEmpty()) then ';' + if (em) then ds.prefixAffectation() 
  + 'entity manager'.apply_attributeFinal() + ' = ' + 'entity manager'.apply_parameterMethodClassicIn() + ';' else '' endif else '' endif/]

[comment écriture de la signature complète d'une opération avec le paramètre en sortie et les paramètres en entrée./]
[query private writePersistSignature(o : soa::Operation) : String = 'public ' + o.outputType() + ' ' + o.nameOperation() + '(' + o.inputSignature() + ')' /]

[comment écriture de la signature complète d'une opération de fallback avec le paramètre en sortie et les paramètres en entrée./]
[query private writeRsFallbackSignature(o : soa::Operation) : String = 'public ' + o.outputType() + ' ' + (o.name() + ' fallback').apply_methodDefault() 
  + '(' + o.inputSignature() + ')' /]
  
[comment écriture de la signature complète d'une opération avec le paramètre en sortie et les paramètres en entrée./]
[query private writePersistSignatureInvoke(o : soa::Operation) : String = 'private ' + o.outputPersistType() + ' ' + o.nameOperation() + '_invoke' 
  + '(' + if (o.paged) then 'final PageRequest ' + 'page request'.apply_parameterMethodClassicIn() else o.inputSignature() endif  + ')' /]
  
[comment écriture de la signature complète d'une opération avec le paramètre en sortie et les paramètres en entrée./]
[query private writeRsSignature(o : soa::Operation) : String = 'public ' + o.writeRsOutput() + ' ' + o.name().apply_methodDefault() 
  + ' (' + o.writeRsInputs() + ')'/]
  
[comment écriture des annotations au niveau de l'opération rest./]
[query private writeRsAnnotations(o : soa::Operation) : String = o.writeRsPreAuthorize() 
  + if (o.verb = soa::Verb::GET) then '@GetMapping(' + o.writeRsUri()
  else if (o.verb = soa::Verb::POST) then '@PostMapping(' + o.writeRsUri()
  else if (o.verb = soa::Verb::PUT) then '@PutMapping(' + o.writeRsUri()
  else if (o.verb = soa::Verb::OPTIONS) then '@RequestMapping(' + o.writeRsUri() + ' method = RequestMethod.OPTIONS)'
  else if (o.verb = soa::Verb::DELETE) then '@DeleteMapping(' + o.writeRsUri()
  else if (o.verb = soa::Verb::HEAD) then '@RequestMapping(' + o.writeRsUri() + ' method = RequestMethod.HEAD)'
  else if (o.verb = soa::Verb::PATCH) then '@PatchMapping(' + o.writeRsUri()
  else if (o.verb = soa::Verb::TRACE) then '' else '' endif endif endif endif endif endif endif endif 
  + if (o.hasToWriteRsProduce()) then 'produces = ' + '"' + if (o.hasMediaRsType()) then  
  o.output->first().mediaRsType() else o.defaultRsMediaType() endif + o.defaultRsEncoding() + '")' 
  else '' endif/]
  
[comment vérifie si il y a besoin d'écrire le paramètre 'produce = './]
[query private hasToWriteRsProduce(o : soa::Operation) : Boolean = o.verb <> soa::Verb::OPTIONS 
  and o.verb <> soa::Verb::TRACE and o.verb <> soa::Verb::HEAD/]

[comment écriture de l'uri pour l'opération./]
[query private writeRsUri(o : soa::Operation) : String =  if (o.rsUri().exists()) then 'value = "'+ o.rsUri() + '", ' 
  else '' endif/]

[comment écriture si besoin de rôles spécifiques en plus de l'authentification pour un service./]  
[query private writeRsPreAuthorize(o : soa::Operation) : String = 
  if (o.has_metaPermission()) then '@PreAuthorize("hasRole(\'' + o.get_metaPermission() + '\')'  
  + if (o.has_metaPermissionOr()()) then ' || hasRole(\'' + o.get_metaPermissionOr() + '\')' else '' endif 
  + if (o.has_metaPermissionAnd()()) then ' && hasRole(\'' + o.get_metaPermissionAnd() + '\')' else '' endif 
  + '")' + o.lineSeparator() else '' endif /]

[comment écriture des annotations au niveau des paramètres rest./]
[query private writeRsAnnotation(p : soa::Parameter, o : soa::Operation) : String = p.writeRsSwaggerAnnotation() + 
 if (o.paged and p.technicalid.equalsIgnoreCase(o.page.technicalid)) then '@RequestParam(name = "' + p.name() + '", '
 else if (o.paged and p.technicalid.equalsIgnoreCase(o.size.technicalid)) then '@RequestParam(name = "' + p.name() + '", '
 else if (p.restData.passingMode = soa::ParameterPassingMode::PATH) then '@PathVariable(name = "' + p.restData.restId + '", '
 else if (p.restData.passingMode = soa::ParameterPassingMode::QUERY) then '@RequestParam(name = "' + p.restData.restId + '", '
 else if (p.restData.passingMode = soa::ParameterPassingMode::HEADER) then '@RequestHeader(name = "' + p.restData.restId + '", '
 else if (p.restData.passingMode = soa::ParameterPassingMode::BODY) then '@RequestBody(' 
 else if (p.restData.passingMode = soa::ParameterPassingMode::COOKIE) then '@CookieValue(name = "' + p.restData.restId + '", '
 else '' endif endif endif endif endif endif endif + 'required = ' + p.isMandatory() +  ')'/]

[comment écriture du statut modélisé pour la réponse, si aucun statut on prend celui par défaut./]
[query private writeRsStatus(o : soa::Operation) : String = if (o.hasRsStatusCode()) then o.output->first().statusCode 
  else o.defaultRsStatusCode() endif/]

[comment écriture de la liste des paramètres en entrée (si existent) pour une opération de type rest./]
[query private writeRsInputs(o : soa::Operation) : String = if (o.hasInputs()) then o.input->asOrderedSet()
  ->collect(o1 : soa::Parameter |  o1.writeRsAnnotation(o)  + ' ' + o1.inputRsType() + ' ' + o1.name().apply_parameterMethodClassicIn())
  ->sep(', ')->toString() else '' endif/]

[comment écriture du paramètre de sortie pour une opération de type rest (toute opération doit avoir un paramètre de sortie, même HEAD et OPTIONS)./]
[query private writeRsOutput(o : soa::Operation) : String =  'ResponseEntity<' + if (not o.mustHaveRsOutput()) 
  then 'Void' else o.outputRsType() endif + '>'/]

[comment écriture de la chaine complète (avec mapper) pour les paramètres en entrée du service domaine./]
[query private writeRsInputsForService(o : soa::Operation) : String = if (o.hasInputs()) then o.input->asOrderedSet()
  ->collect(p : soa::Parameter | p.writeRsInputForService())->sep(', ')->toString() + if(o.paged) then ', ' 
  + 'sort by'.apply_variableDefault() else '' endif else '' endif/]

[comment écriture particulière pour les opérations de type HEAD qui n'ont pas de paramètre de sortie./]
[query private writeRsHeadOptionOperation(o : soa::Operation, s : soa::Service) : String = if (not o.mustHaveRsOutput()) 
  then 'HttpHeaders ' + 'headers'.apply_variableDefault() + '= new HttpHeaders();' + o.lineSeparator() + 'headers'.apply_variableDefault() 
  + '.add(' + if (o.verb = soa::Verb::OPTIONS) then '"Allow", "<GET|POST|DELETE|OPTIONS|ETC...>");' else '"X-", "<VOTRE PARAMETRE>");' endif
  + o.lineSeparator() +  'return ResponseEntity.ok().headers(' + 'headers'.apply_variableDefault() + ').build();' else '' endif/]

[comment écriture du builder pour l'objet de réponse du service rest./]
[query private writeRsResponseBuilder(o : soa::Operation) : String = if (o.mustHaveRsOutput()) then 'ResponseEntity.BodyBuilder ' 
  + 'response builder'.apply_variableDefault() + ' = ResponseEntity.status(' + o.writeRsStatus() + ');' else '' endif/]

[comment écriture de la requête pour le service rest, sert d'aiguillage pour les autres queries en fonction du type de sortie./]
[query private writeRsOperation(o : soa::Operation, s : soa::Service) : String =  if (o.mustHaveRsOutput()) then 
 if (o.output->first().rsIsOptional()) then if(o.output->first().isMultiple()) then o.writeRsOptionalOutputStar(s) else o.writeRsOptionalOutputOne(s) endif 
 else if(o.output->first().isMultiple()) then o.writeRsNonOptionalOutputStar(s) else o.writeRsNonOptionalOutputOne(s) endif endif + ';' else '' endif/]
 
[comment écriture pour un résultat optionnel sur un enregistrement (plus compliqué car deux réponses complétement différentes si dto ou primitif)./]
[query private writeRsOptionalOutputOne(o : soa::Operation, s : soa::Service) : String =  if (o.output->first().type.oclIsKindOf(environment::DTO)) 
  then 'return ' + o.prefixAffectation() + s.name().apply_attributeFinal() + '.' + o.nameOperation() + '(' + o.writeRsInputsForService() 
  + ').map(o -> ' + 'response builder'.apply_variableDefault() + '.body(' + o.output->first().type.oclAsType(environment::DTO).nameClassMapperImpl() 
  + '.' + ('to ' + o.suffixXto()).apply_methodDefault() + '(o))).orElseThrow(() -> new ' + o.nameClassRsDataNotFoundExceptionImpl() + '(' 
  + if (o.hasRsNotFoundFault()) then o.notRsFoundFault().statusCode + ', "' + o.notRsFoundFault().statusMessage else o.defaultRsNotFoundStatusCode1() 
  + ', "' endif + '"))' 
  
  else 'Optional<String>' +  'value'.apply_variableDefault() + '= ' + o.prefixAffectation() + s.name().apply_attributeFinal() 
  + '.' + o.nameOperation() + '(' + o.writeRsInputsForService()  + ');' + 'if (' + 'value'.apply_variableDefault() + '.isPresent()) { return ' 
  + 'response builder'.apply_variableDefault() + '.body(' + 'value'.apply_variableDefault() + '.get());} else throw new ' + o.nameClassRsDataNotFoundExceptionImpl() 
  + '(' + if (o.hasRsNotFoundFault()) then o.notRsFoundFault().statusCode + ', "' + o.notRsFoundFault().statusMessage else o.defaultRsNotFoundStatusCode1() 
  + ', "' endif + '")' endif/]

[comment écriture pour un résultat optionnel sur une liste d'enregistrements (pour l'instant 200 avec liste vide)./]
[query private writeRsOptionalOutputStar(o : soa::Operation, s : soa::Service) : String = 'return ' + 'response builder'.apply_variableDefault() + '.body(' +
  if (o.output->first().type.oclIsKindOf(environment::DTO)) then o.prefixAffectation() + s.name().apply_attributeFinal() 
  + '.' + o.nameOperation() + '(' + o.writeRsInputsForService() + ').stream().map(o -> ' + o.output->first().type.oclAsType(environment::DTO).nameClassMapperImpl() 
  + '.' + ('to ' + o.suffixXto()).apply_methodDefault() + '(o)).collect(Collectors.toList()))' else o.prefixAffectation() + s.name().apply_attributeFinal() + '.' 
  + o.nameOperation() + '(' + o.writeRsInputsForService() + '))' endif/]

[comment écriture pour un résultat obligatoire sur un enregistrement./]
[query private writeRsNonOptionalOutputOne(o : soa::Operation, s : soa::Service) : String = 'return ' + 'response builder'.apply_variableDefault() 
  + '.body(' + if (o.output->first().type.oclIsKindOf(environment::DTO)) then o.output->first().type.oclAsType(environment::DTO).nameClassMapperImpl() 
  + '.' + 'to xto'.apply_methodDefault() + '(' + o.prefixAffectation() + s.name().apply_attributeFinal() + '.' + o.nameOperation() 
  + '(' + o.writeRsInputsForService() + ')))' else o.prefixAffectation() + s.name().apply_attributeFinal() + '.' + o.nameOperation() 
  + '(' + o.writeRsInputsForService() + '))' endif /]

[comment écriture pour un résultat obligatoire sur un liste d'enregistrements./]
[query private writeRsNonOptionalOutputStar(o : soa::Operation, s : soa::Service) : String = 'return ' + 'response builder'.apply_variableDefault() + '.body(' +
   if (o.output->first().type.oclIsKindOf(environment::DTO)) then  o.prefixAffectation() + s.name().apply_attributeFinal() 
   + '.' + o.nameOperation() + '(' + o.writeRsInputsForService() + ').stream().map(o -> ' + o.output->first().type.oclAsType(environment::DTO).nameClassMapperImpl() 
   + '.' + ('to ' + o.suffixXto()).apply_methodDefault() + '(o)).collect(Collectors.toList()))' else o.prefixAffectation() + s.name().apply_attributeFinal() + '.' 
   + o.nameOperation() + '(' + o.writeRsInputsForService() + '))' endif/]

[comment écriture de la chaine complète (avec mapper) pour les paramètres en entrée du service domaine./]
[query private writeRsInputForService(p : soa::Parameter) : String = if (p.type.oclIsKindOf(environment::DTO)) 
  then if (p.isMultiple()) then p.name().apply_parameterMethodClassicIn() + '.stream().map(o -> ' +  p.type.oclAsType(environment::DTO).nameClassMapperImpl() 
  + '.' + ('to ' + p.suffixDto()).apply_methodDefault() + '(o)).collect(Collectors.toList())' else  p.type.oclAsType(environment::DTO).nameClassMapperImpl() + '.' 
  + ('to ' + p.suffixDto()).apply_methodDefault() + '(' + p.name().apply_parameterMethodClassicIn() + ')' endif 
  else p.name().apply_parameterMethodClassicIn() endif /]

[comment écriture de l'annotion explicative pour swagger-ui (pour paramètre en body un seul, mais plus simple d'utiliser la boucle)./]
[query private writeRsSwaggerAnnotation(o : soa::Operation, ss : soa::SecurityScheme) : String = '@Operation(operationId = "' + o.name() + '", description = "' 
  + o.writeDescription() + '", tags = {"' + o.eContainer(soa::Service).name() + '"}' + if (o.isRsSecured()) then ', security = ' + if (ss.type = soa::SecuritySchemeType::OAUTH2 
  or ss.type = soa::SecuritySchemeType::OPEN_ID_CONNECT) then '{' + ss.flows->collect(o0 | '@SecurityRequirement(name = "' +  ss.name + '_' 
  + o0.flowType.toString().toLower() + '")')->sep(',') + '}' else '@SecurityRequirement(name = "' + ss.name + '")' endif  else '' endif + if (o.hasInputs() and not 
  o.input->select(o1 | o1.restData.passingMode = soa::ParameterPassingMode::BODY)->isEmpty()) then ', requestBody = @io.swagger.v3.oas.annotations.parameters.RequestBody(' 
  +  o.input->select(o1 | o1.restData.passingMode = soa::ParameterPassingMode::BODY)->collect(o2 | ' required = true, description = "' 
  + o2.writeDescription() + '", content = @Content( mediaType = "' + if (o2.hasMediaRsType()) then o2.mediaRsType() else o2.defaultRsMediaType() endif 
  + '", schema = @Schema(implementation = ' + o2.inputRsType().replaceAll('\\b(?:List|Set)<([^<>]+)>', '$1')  + '.class)))') else '' endif 
  + if (o.hasInputs() and not o.input->select(o3 | o3.restData.passingMode <> soa::ParameterPassingMode::BODY)->isEmpty() ) then ', parameters = {' 
  + o.input->select(o4 | o4.restData.passingMode <> soa::ParameterPassingMode::BODY)->collect(o5 | '@Parameter( '+ 'name = "' + o5.restData.restId 
  + '", description = "' + o5.writeDescription() + '", required = ' + o5.isMandatory() + ', in = ParameterIn.' + o5.restData.passingMode 
  + ', example = "")')->sep(', ') +  '}' else '' endif + ')' + '@ApiResponses(value = { ' + if (o.hasOutput()) then '@ApiResponse(responseCode = "'
  + o.output->first().statusCode + '", description = "' + o.output->first().statusMessage + '", content = @Content(mediaType = "' 
  + if (o.hasMediaRsType()) then o.output->first().mediaRsType() else o.defaultRsMediaType() endif + '", schema = @Schema(implementation = ' 
  + o.outputRsType().replaceAll('\\b(?:List|Set)<([^<>]+)>', '$1') + '.class)))' else '' endif + if(not o.fault->isEmpty()) then ', ' else '' endif 
  + o.fault->collect(o6 | '@ApiResponse(responseCode = "' + o6.statusCode + '", description = "' + o6.statusMessage + '")')->sep(', ') + '})'/]

[comment écriture de l'annotion explicative pour swagger-ui (vide pour l'instant car redondant avec l'opération) attention à ne 
  pas confondre avec writeRsSwaggerAnnotation<s>./]
[query private writeRsSwaggerAnnotation(p : soa::Parameter) : String = ''/]

[comment écriture des annotations explicatives pour la documentation swagger-ui./]
[query private writeRsSwaggerAnnotations(c : soa::Component, s : soa::SecurityScheme) : String = '@OpenAPIDefinition(info = @Info(title = "' 
  + c.name + '", version = "' + c.versionOpenApi() + '", description = "' + c.writeDescription() + '", termsOfService = "' + c.information.termsOfService 
  + '", contact = @Contact( name = "'+ c.contact.name + '", email = "' + c.contact.email + '", url = "' + c.contact.URL + '"), license = @License( ' 
  + 'name = "' + c.license.name + '", url = "' + c.license.URL + '"))' + if (not c.servers->isEmpty()) then ', servers = {' + c.servers->collect(o | '@Server(url = "' 
  + o.URL + '", description = "' + o.writeDescription() + '")')->sep(', ') + '}' else '' endif + if (s.exists()) then ', security = { ' 
  + if(s.type = soa::SecuritySchemeType::API_KEY or s.type = soa::SecuritySchemeType::HTTP) then '@SecurityRequirement(name = "' 
  + s.name + '")' else s.flows->collect(o | '@SecurityRequirement(name = "' + s.name + '_' + o.flowType.toString().toLower() + '")')->sep(', ') endif + '})' 
  + s.lineSeparator() + if (s.type = soa::SecuritySchemeType::API_KEY or s.type = soa::SecuritySchemeType::HTTP) then s.writeRsSecuritySchemeSwaggerAnnotations(null) 
  else s.flows->collect(o | s.writeRsSecuritySchemeSwaggerAnnotations(o))->sep(s.lineSeparator()) endif else ')' endif/]

[comment écriture de la seconde annotation explicative (pour oauth2 et openid si plusieurs flows, plusieurs annotations)./]
[comment pour l'instant il faudrait bloquer à un seul flow, sinon on ne sait pas comment raccorder au niveau de l'opération./]
[query private writeRsSecuritySchemeSwaggerAnnotations(s : soa::SecurityScheme, f : soa::Flow) : String = '@SecurityScheme(name = "' 
  + s.name + if(s.type = soa::SecuritySchemeType::OAUTH2 or s.type = soa::SecuritySchemeType::OPEN_ID_CONNECT) then '_' + f.flowType.toString().toLower() else '' endif 
  + '", type = SecuritySchemeType.' + s.type.toString().toUpper() + if (s.type = soa::SecuritySchemeType::API_KEY) then ', in = SecuritySchemeIn.' 
  + s.apiKeyLocation.toString().toUpper() + ', paramName = "' + s.key + '"' else if (s.type = soa::SecuritySchemeType::HTTP) then ', scheme="' 
  + s.httpScheme + '"' + if (s.httpScheme = soa::HttpScheme::BEARER) then ', bearerFormat  = "' + s.format.toUpper() + '"' else '' endif 
  else if (s.type = soa::SecuritySchemeType::OPEN_ID_CONNECT) then ', openIdConnectUrl = "'+ s.connectURL + '"' else ', flows = @OAuthFlows(' 
  + f.transcodeRsFlow() + ' = @OAuthFlow(' + if (f.flowType = soa::FlowType::AUTHORIZATIONCODE or f.flowType = soa::FlowType::IMPLICIT) 
  then 'authorizationUrl = "' + f.authorizationURL + '"' else '' endif + if (f.flowType <> soa::FlowType::IMPLICIT) 
  then if (f.flowType = soa::FlowType::AUTHORIZATIONCODE) then ', ' else '' endif + 'tokenUrl = "'+ f.tokenURL + '"' else '' endif  + ', scopes = {' 
  + f.scopes->collect(o | '@OAuthScope(name = "'+ o.name + '", description = "'+ o.writeDescription() + '")')->sep(', ' + f.lineSeparator()) + '}' 
  + '))' endif endif endif + ')'/]
  
[comment simple transcodage entre la dénomination du flow modélisée et celle attendue par springdoc./]
[query private transcodeRsFlow(f : soa::Flow) : String = 
  if (f.flowType = soa::FlowType::IMPLICIT) then 'implicit' 
  else if (f.flowType = soa::FlowType::CREDENTIALS) then 'clientCredentials' 
  else if (f.flowType = soa::FlowType::AUTHORIZATIONCODE) then 'authorizationCode ' 
  else if (f.flowType = soa::FlowType::PASSWORD) then 'password' 
  else f.cNoModelisation() endif endif endif endif/]
