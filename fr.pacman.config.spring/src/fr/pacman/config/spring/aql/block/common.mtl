[module common(	'http://www.obeonetwork.org/dsl/overview/2.0.0')/]

[import fr::pacman::core::aql::base/]
[import fr::pacman::core::aql::name::classes/]
[import fr::pacman::core::aql::name::packages/]
[import fr::pacman::core::aql::output::headers/]
[import fr::pacman::core::aql::rule::parameter/]
[import fr::pacman::core::aql::rule::variable/]
[import fr::pacman::core::aql::rule::method/]

[import fr::pacman::core::property::project::ProjectProperties/]

[comment écriture du fichier de configuration Maven pour le sous-projet métier (domain)./]
[template public pom (any : ecore::EObject)]
  <project xmlns="http://maven.apache.org/POM/4.0.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <modelVersion>4.0.0</modelVersion>
    
    <parent>
        <groupId>[any.namePackageProject()/]</groupId>
        <artifactId>[any.nameProject()/]</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
    <artifactId>[any.nameProjectCommon()/]</artifactId>
    <packaging>jar</packaging>
    
    <dependencies>
       <dependency>
          <groupId>org.junit.jupiter</groupId>
          <artifactId>junit-jupiter</artifactId>
          <scope>test</scope>
       </dependency>
    </dependencies>
    
    <build>
      <plugins>
         <!-- Vérification des prérequis pour le module métier. -->
         <!-- ************************************************** --> 
         <!-- Placer ici uniquement les dépendances authorisées. --> 
         <!-- ************************************************** -->
         <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-enforcer-plugin</artifactId>
            <executions>
               <execution>
                  <goals>
                     <goal>enforce</goal>
                  </goals>
                  <configuration>
                     <rules>
                        <bannedDependencies>
                           <excludes>
                              <exclude>*</exclude>                              
                           </excludes>
                           <includes>
                              <!-- Placer ici les librairies authorisées. -->
                              <!-- Pour l'instant uniquement librairies de test. -->
                              <include>*:*:*:*:test</include>
                           </includes>
                        </bannedDependencies>
                     </rules>
                  </configuration>
               </execution>
            </executions>
         </plugin>
      </plugins>
    </build>
  </project>
[/template]


[comment écriture de l'annotation pour l'injection de service métier./]
[template public annotationOut(any : ecore::EObject)]
  [any.classHeader(any.namePackageAnnotation())/]
  [any.defaultImports()/]
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;

  /** 
   * Annotation personnalisée pour marquer les services du domaine dans
   * l'application.
   * <p>
   * Cette annotation est utilisée pour indiquer qu'une classe fait partie du
   * domaine métier de l'application, généralement utilisée pour désigner les
   * services ou les composants qui gèrent la logique métier. Elle est disponible
   * à l'exécution grâce à {@link RetentionPolicy#RUNTIME}.
   * </p>
   * Cette annotation ne comporte actuellement aucun élément spécifique, mais peut
   * être étendue à l'avenir pour ajouter des métadonnées supplémentaires si
   * nécessaire.
   *
   * @author [any.get_authorName()/]
   */
   @Retention(RetentionPolicy.RUNTIME)
   public @interface [any.nameClassAnnotationOut()/] {
     //RAS.
   }
[/template]

[comment écriture de l'annotation pour l'injection de service persistance./]
[template public annotationIn(any : ecore::EObject)]
  [any.classHeader(any.namePackageAnnotation())/]
  [any.defaultImports()/]
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;

  /**
   * Annotation personnalisée pour marquer les adaptateurs de service dans
   * l'application.
   * <p>
   * Cette annotation est utilisée pour identifier les classes qui servent
   * d'adaptateurs pour les services. Les adaptateurs de service sont généralement
   * utilisés pour intégrer des services externes ou des composants spécifiques à
   * l'architecture de l'application tout en offrant une interface uniforme. Elle
   * est disponible à l'exécution grâce à {@link RetentionPolicy#RUNTIME}.
   * </p>
   * Cette annotation ne comporte actuellement aucun élément spécifique, mais peut
   * être étendue à l'avenir pour ajouter des métadonnées supplémentaires si
   * nécessaire.
   * 
   * @author [any.get_authorName()/]
   */
   @Retention(RetentionPolicy.RUNTIME)
   public @interface [any.nameClassAnnotationIn()/] {
     //RAS.
   }
[/template]

[comment écriture de l'annotation pour l'injection de service persistance./]
[template public annotationTrans(any : ecore::EObject)]
  [any.classHeader(any.namePackageAnnotation())/]
  [any.defaultImports()/]
  import java.lang.annotation.Retention;
  import java.lang.annotation.RetentionPolicy;
  
  /**
   * Annotation personnalisée marquant les méthodes ou les classes qui doivent
   * être exécutées dans un contexte transactionnel. Cette annotation peut être
   * utilisée pour indiquer qu'une méthode ou une classe doit être traitée dans
   * une transaction.
   * <p>
   * Elle peut être utilisée en combinaison avec un gestionnaire de transactions,
   * tel qu'un aspect, pour appliquer la logique transactionnelle. 
   * 
   * @see org.springframework.transaction.annotation.Transactional
   * @see [any.nameClassJpaTransactionExecutorImpl()/]
   *   * @author [any.get_authorName()/]
   */
   @Retention(RetentionPolicy.RUNTIME)
   public @interface [any.nameClassAnnotationTrans()/] {
     //RAS
   }
[/template]

[comment écriture du valideur pour l'ensemble des objets métiers./]
[template public validatorUtilsImpl(any : ecore::EObject)]
  [any.classHeader(any.namePackageCommonUtils())/]
  [any.defaultImports()/]
  
  /**
   * Classe utilitaire contenant des méthodes de validation pour vérifier certaines contraintes
   * sur des champs de données. Ces méthodes vérifient des conditions telles que la présence 
   * d'une valeur obligatoire ou la taille d'une chaîne de caractères.
   * <p>
   * Cette classe n'a pas besoin d'être instanciée, car elle contient uniquement des méthodes statiques.</p>
   * 
   * @author [any.get_authorName()/]
   */
  public class [any.nameClassValidatorUtilsImpl()/]
  {
   /**
    * Vérifie si une valeur obligatoire (non nulle) est fournie pour un champ.
    * Si la valeur est nulle, le nom du champ est ajouté à la liste des champs invalides.
    *
    * @param ['field name'.apply_parameterMethodClassicIn()/] Le nom du champ à valider.
    * @param ['value'.apply_parameterMethodClassicIn()/]   La valeur du champ à vérifier.
    * @param ['invalid fields'.apply_parameterMethodClassicIn()/] La liste des champs invalides à laquelle ajouter le nom du champ en cas de validation échouée.
    */
    public static void ['check mandatory'.apply_methodDefault()/](final String ['field name'.apply_parameterMethodClassicIn()/]
       , final Object ['value'.apply_parameterMethodClassicIn()/], List<String> ['invalid fields'.apply_parameterMethodClassicIn()/]) 
       {
       if (['value'.apply_parameterMethodClassicIn()/] == null) {
          if (['invalid fields'.apply_parameterMethodClassicIn()/] == null) {
             ['invalid fields'.apply_parameterMethodClassicIn()/] = new ArrayList<>();
          }
          ['invalid fields'.apply_parameterMethodClassicIn()/].add(['field name'.apply_parameterMethodClassicIn()/]);
       }
    }
    
   /**
    * Vérifie si la taille d'une chaîne de caractères est comprise dans une plage spécifiée.
    * Si la taille dépasse la taille maximale autorisée, une entrée est ajoutée à la liste des champs invalides
    * indiquant la taille actuelle de la chaîne et la taille maximale autorisée. 
    * <p>
    * Si la chaîne est nulle, cette méthode ne fait aucune vérification.</p>
    *
    * @param ['field name'.apply_parameterMethodClassicIn()/] Le nom du champ à valider.
    * @param ['value'.apply_parameterMethodClassicIn()/]   La valeur du champ (une chaîne de caractères) à vérifier.
    * @param ['min size'.apply_parameterMethodClassicIn()/]  La taille minimale autorisée pour la chaîne.
    * @param ['max size'.apply_parameterMethodClassicIn()/]  La taille maximale autorisée pour la chaîne.
    * @param ['invalid fields'.apply_parameterMethodClassicIn()/] La liste des champs invalides à laquelle ajouter une entrée en cas de validation échouée.
    */
    public static void ['check size'.apply_methodDefault()/](final String ['field name'.apply_parameterMethodClassicIn()/]
       , final String ['value'.apply_parameterMethodClassicIn()/], final int ['min size'.apply_parameterMethodClassicIn()/] 
       , final int ['max size'.apply_parameterMethodClassicIn()/], List<String> ['invalid fields'.apply_parameterMethodClassicIn()/]) 
         {
       if (['value'.apply_parameterMethodClassicIn()/] != null && ['value'.apply_parameterMethodClassicIn()/]
          .length() > ['max size'.apply_parameterMethodClassicIn()/]) {
          if (['invalid fields'.apply_parameterMethodClassicIn()/] == null) {
              ['invalid fields'.apply_parameterMethodClassicIn()/] = new ArrayList<>();
          }
          ['invalid fields'.apply_parameterMethodClassicIn()/].add(['field name'.apply_parameterMethodClassicIn()/] 
             + " (" + ['value'.apply_parameterMethodClassicIn()/].length() + " > " + ['max size'.apply_parameterMethodClassicIn()/] + ")");
    	}
    }
  }
[/template]